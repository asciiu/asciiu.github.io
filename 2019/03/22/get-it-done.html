<!DOCTYPE html>
<html lang="en">
    <head>
        
        <title>Get it done! | </title>
        

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

        <!-- Begin Jekyll SEO tag v2.6.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Get it done!" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="During the mid 90’s, Steve Jobs once said that the difference between an average programmer and a gifted programmer is 50:1 - maybe even as high as 100:1. Image that! What if you were 100 times more effective than you are today? There would be virtually nothing that you could not accomplish! I think many programmers can be more productive if they did the following: Stop overanalyzing things. “It’s like a finger pointing away to the moon. Don’t concentrate on the finger or you will miss all that heavenly glory.” - Bruce Lee Overanalyzing things slows programmers down and is a waste of time. I can’t tell you how much time I have wasted overanalyzing my code. My best work has often been a result of spontaneity. When I had started my career fresh out college, I was too focused on perfection. My code was clean and elegant. I used all the correct patterns to ensure that my code was pretty and extensible for World War X. The thing is, most of the situations that I coded for never happened, and I wasted a lot of time overthinking things. In retrospect, I would have been a more productive coder by at least a magnitude or more had I kicked perfection to the curb. Good code is an on-going process that doesn’t happen all at once. The process unfolds naturally as the ideas and relationships make themselves visible while you work. If you think things over too hard you cut yourself off to true genius. Learning new technologies is fun, but don’t allow yourself to get lost down the rabbit hole. If your goal is to release a product and you’ve already put work into it, go the rest of the way using the technology that you started with. I’ve redone login registration after login registration in various frameworks/languages because I thought it was going to be better. In retrospect it was not a good idea. Do not think that because a new technology is subjectively better that it is going to solve all your issues. Stick to your original plan and get it done. Make compromises if you have to, but keep your eye on your target. Get your product out there! Your first version won’t be perfectly polished nor should it be using cutting edge technology. If you’re going to be on the cutting edge you’re going to encounter bugs or other issues that you can’t Google for because nobody has encountered it yet. This is not to say that you shouldn’t switch tools if your current tool set is not a good fit. You really should be using the correct tool to begin with. No, that is to say, it’s better to stick with your current toolset if you know that it will get the job done. Do not switch unless you absolutely have to. You’ll be revisiting a lot of ground that you have already covered otherwise. It certainly makes sense to do new things with new technology, but redoing existing things that already work is rarely a good idea. Every company that I have worked for that has tried to reimplement the legacy codebase has failed. Nobody cares how pretty your code is. At the end of the day, what matters most is if your product works. More importantly, your product needs to generate revenue. As an engineer I like my work to be maintainable and clean. But in all seriousness the users do not care what your code looks like. If you want to break out of your engineering cubicle and make it on your own you have to drop the “Software Engineer” mentality and stop being pedantic about the quality of code that you write. Does the product work? Is it stable and relatively free of defects? Is the codebase just readable enough without it being a hindrance to moving forward? The “Software Engineer” mentality is great when you want to remain employed, but it is terribly unproductive for entrepreneurs. Be results driven first!" />
<meta property="og:description" content="During the mid 90’s, Steve Jobs once said that the difference between an average programmer and a gifted programmer is 50:1 - maybe even as high as 100:1. Image that! What if you were 100 times more effective than you are today? There would be virtually nothing that you could not accomplish! I think many programmers can be more productive if they did the following: Stop overanalyzing things. “It’s like a finger pointing away to the moon. Don’t concentrate on the finger or you will miss all that heavenly glory.” - Bruce Lee Overanalyzing things slows programmers down and is a waste of time. I can’t tell you how much time I have wasted overanalyzing my code. My best work has often been a result of spontaneity. When I had started my career fresh out college, I was too focused on perfection. My code was clean and elegant. I used all the correct patterns to ensure that my code was pretty and extensible for World War X. The thing is, most of the situations that I coded for never happened, and I wasted a lot of time overthinking things. In retrospect, I would have been a more productive coder by at least a magnitude or more had I kicked perfection to the curb. Good code is an on-going process that doesn’t happen all at once. The process unfolds naturally as the ideas and relationships make themselves visible while you work. If you think things over too hard you cut yourself off to true genius. Learning new technologies is fun, but don’t allow yourself to get lost down the rabbit hole. If your goal is to release a product and you’ve already put work into it, go the rest of the way using the technology that you started with. I’ve redone login registration after login registration in various frameworks/languages because I thought it was going to be better. In retrospect it was not a good idea. Do not think that because a new technology is subjectively better that it is going to solve all your issues. Stick to your original plan and get it done. Make compromises if you have to, but keep your eye on your target. Get your product out there! Your first version won’t be perfectly polished nor should it be using cutting edge technology. If you’re going to be on the cutting edge you’re going to encounter bugs or other issues that you can’t Google for because nobody has encountered it yet. This is not to say that you shouldn’t switch tools if your current tool set is not a good fit. You really should be using the correct tool to begin with. No, that is to say, it’s better to stick with your current toolset if you know that it will get the job done. Do not switch unless you absolutely have to. You’ll be revisiting a lot of ground that you have already covered otherwise. It certainly makes sense to do new things with new technology, but redoing existing things that already work is rarely a good idea. Every company that I have worked for that has tried to reimplement the legacy codebase has failed. Nobody cares how pretty your code is. At the end of the day, what matters most is if your product works. More importantly, your product needs to generate revenue. As an engineer I like my work to be maintainable and clean. But in all seriousness the users do not care what your code looks like. If you want to break out of your engineering cubicle and make it on your own you have to drop the “Software Engineer” mentality and stop being pedantic about the quality of code that you write. Does the product work? Is it stable and relatively free of defects? Is the codebase just readable enough without it being a hindrance to moving forward? The “Software Engineer” mentality is great when you want to remain employed, but it is terribly unproductive for entrepreneurs. Be results driven first!" />
<link rel="canonical" href="/2019/03/22/get-it-done.html" />
<meta property="og:url" content="/2019/03/22/get-it-done.html" />
<meta property="og:site_name" content="Hello Entrepreneur." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-22T00:00:00-06:00" />
<script type="application/ld+json">
{"description":"During the mid 90’s, Steve Jobs once said that the difference between an average programmer and a gifted programmer is 50:1 - maybe even as high as 100:1. Image that! What if you were 100 times more effective than you are today? There would be virtually nothing that you could not accomplish! I think many programmers can be more productive if they did the following: Stop overanalyzing things. “It’s like a finger pointing away to the moon. Don’t concentrate on the finger or you will miss all that heavenly glory.” - Bruce Lee Overanalyzing things slows programmers down and is a waste of time. I can’t tell you how much time I have wasted overanalyzing my code. My best work has often been a result of spontaneity. When I had started my career fresh out college, I was too focused on perfection. My code was clean and elegant. I used all the correct patterns to ensure that my code was pretty and extensible for World War X. The thing is, most of the situations that I coded for never happened, and I wasted a lot of time overthinking things. In retrospect, I would have been a more productive coder by at least a magnitude or more had I kicked perfection to the curb. Good code is an on-going process that doesn’t happen all at once. The process unfolds naturally as the ideas and relationships make themselves visible while you work. If you think things over too hard you cut yourself off to true genius. Learning new technologies is fun, but don’t allow yourself to get lost down the rabbit hole. If your goal is to release a product and you’ve already put work into it, go the rest of the way using the technology that you started with. I’ve redone login registration after login registration in various frameworks/languages because I thought it was going to be better. In retrospect it was not a good idea. Do not think that because a new technology is subjectively better that it is going to solve all your issues. Stick to your original plan and get it done. Make compromises if you have to, but keep your eye on your target. Get your product out there! Your first version won’t be perfectly polished nor should it be using cutting edge technology. If you’re going to be on the cutting edge you’re going to encounter bugs or other issues that you can’t Google for because nobody has encountered it yet. This is not to say that you shouldn’t switch tools if your current tool set is not a good fit. You really should be using the correct tool to begin with. No, that is to say, it’s better to stick with your current toolset if you know that it will get the job done. Do not switch unless you absolutely have to. You’ll be revisiting a lot of ground that you have already covered otherwise. It certainly makes sense to do new things with new technology, but redoing existing things that already work is rarely a good idea. Every company that I have worked for that has tried to reimplement the legacy codebase has failed. Nobody cares how pretty your code is. At the end of the day, what matters most is if your product works. More importantly, your product needs to generate revenue. As an engineer I like my work to be maintainable and clean. But in all seriousness the users do not care what your code looks like. If you want to break out of your engineering cubicle and make it on your own you have to drop the “Software Engineer” mentality and stop being pedantic about the quality of code that you write. Does the product work? Is it stable and relatively free of defects? Is the codebase just readable enough without it being a hindrance to moving forward? The “Software Engineer” mentality is great when you want to remain employed, but it is terribly unproductive for entrepreneurs. Be results driven first!","@type":"BlogPosting","url":"/2019/03/22/get-it-done.html","headline":"Get it done!","dateModified":"2019-03-22T00:00:00-06:00","datePublished":"2019-03-22T00:00:00-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/03/22/get-it-done.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata|PT+Sans">
        <link rel="stylesheet" href="https://unpkg.com/basscss@8.0.2/css/basscss.min.css">

        <link rel="stylesheet" type="text/css" href="/assets/css/main.css">
    </head>

    <body>
        <div class="max-width-3 mx-auto">
            <div class="clearfix">
                <div class="col col-6">
                    <h1>
                        <a href="/" class="site-title">
                            Hello Entrepreneur.
                        </a>
                    </h1>
                </div>

                <div class="col col-6">
                    <ul class="list-reset right-align">
                        
                    </ul>
                </div>
            </div>

            <div class="border-top">
                <div class="clearfix">
    <div class="col col-6">
        <h2>Get it done!</h2>
    </div>
    <div class="col col-6">
        <p class="right-align">March 22, 2019</p>
    </div>
</div>

<div class="clearfix">
    <div class="col col-12">
        <p>During the mid 90’s, Steve Jobs once said that the difference between an average programmer and a gifted programmer is 50:1 - maybe even as high as 100:1. Image that! What if you were 100 times more effective than you are today? There would be virtually nothing that you could not accomplish! I think many programmers can be more productive if they did the following:</p>

<h3 id="stop-overanalyzing-things">Stop overanalyzing things.</h3>

<p>“It’s like a finger pointing away to the moon. Don’t concentrate on the finger or you will miss all that heavenly glory.” - Bruce Lee</p>

<p>Overanalyzing things slows programmers down and is a waste of time. I can’t tell you how much time I have wasted overanalyzing my code. My best work has often been a result of spontaneity.</p>

<p>When I had started my career fresh out college, I was too focused on perfection. My code was clean and elegant. I used all the correct patterns to ensure that my code was pretty and extensible for World War X. The thing is, most of the situations that I coded for never happened, and I wasted a lot of time overthinking things. In retrospect, I would have been a more productive coder by at least a magnitude or more had I kicked perfection to the curb.</p>

<p>Good code is an on-going process that doesn’t happen all at once. The process unfolds naturally as the ideas and relationships make themselves visible while you work. If you think things over too hard you cut yourself off to true genius.</p>

<h3 id="learning-new-technologies-is-fun-but-dont-allow-yourself-to-get-lost-down-the-rabbit-hole">Learning new technologies is fun, but don’t allow yourself to get lost down the rabbit hole.</h3>

<p>If your goal is to release a product and you’ve already put work into it, go the rest of the way using the technology that you started with. I’ve redone login registration after login registration in various frameworks/languages because I thought it was going to be better. In retrospect it was not a good idea.</p>

<p>Do not think that because a new technology is subjectively better that it is going to solve all your issues. Stick to your original plan and get it done. Make compromises if you have to, but keep your eye on your target. Get your product out there! Your first version won’t be perfectly polished nor should it be using cutting edge technology. If you’re going to be on the cutting edge you’re going to encounter bugs or other issues that you can’t Google for because nobody has encountered it yet.</p>

<p>This is not to say that you shouldn’t switch tools if your current tool set is not a good fit. You really should be using the correct tool to begin with. No, that is to say, it’s better to stick with your current toolset if you know that it will get the job done. Do not switch unless you absolutely have to. You’ll be revisiting a lot of ground that you have already covered otherwise. It certainly makes sense to do new things with new technology, but redoing existing things that already work is rarely a good idea. Every company that I have worked for that has tried to reimplement the legacy codebase has failed.</p>

<h3 id="nobody-cares-how-pretty-your-code-is">Nobody cares how pretty your code is.</h3>

<p>At the end of the day, what matters most is if your product works. More importantly, your product needs to generate revenue. As an engineer I like my work to be maintainable and clean. But in all seriousness the users do not care what your code looks like. If you want to break out of your engineering cubicle and make it on your own you have to drop the “Software Engineer” mentality and stop being pedantic about the quality of code that you write. Does the product work? Is it stable and relatively free of defects? Is the codebase just readable enough without it being a hindrance to moving forward? The “Software Engineer” mentality is great when you want to remain employed, but it is terribly unproductive for entrepreneurs. Be results driven first!</p>

    </div>
</div>

            </div>
        </div>
    </body>
</html>
